<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Video Chat Room</title>
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        :root{
            --bg: #040404;
            --panel: #080202; /* deep black with slight red tint */
            --muted: #cfcfcf;
            --accent: #ff2d2d; /* vivid red accent */
            --glass: rgba(255,45,45,0.06);
            --glass-2: rgba(255,255,255,0.02);
        }

        html,body{height:100%;}
        body{
            margin:0;
            min-height:100%;
            background: linear-gradient(180deg, var(--bg), #000000 60%);
            color: #f3f3f3;
            font-family: Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
            -webkit-font-smoothing:antialiased;
            padding:28px;
            box-sizing:border-box;
        }

        .topbar{
            display:flex;
            align-items:center;
            justify-content:space-between;
            gap:12px;
            margin-bottom:18px;
            border-bottom:1px solid var(--glass-2);
            padding-bottom:12px;
        }

        .brand{
            font-weight:700;
            letter-spacing:0.4px;
            font-size:18px;
            color:var(--accent);
        }

        .subtitle{ color:var(--muted); font-size:13px }

        #videos{ display:flex; gap:18px; flex-wrap:wrap; align-items:flex-start }

        video{ display:block; width:100%; max-width:720px; background:#000; border-radius:12px; box-shadow:0 8px 30px rgba(0,0,0,0.7); border:1px solid rgba(255,0,0,0.06) }
        /* Mirror only the local preview so it looks natural to the user */
        #preview{ transform: scaleX(-1); }
        /* Remote videos should not be mirrored */
        #remoteVideos video{ transform: none; }

        #remoteVideos{ display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:12px; width:100%; max-width:720px }

        .controls{
            margin-top:18px;
            display:flex;
            gap:10px;
            align-items:center;
            flex-wrap:wrap;
            background:linear-gradient(180deg, rgba(0,0,0,0.6), rgba(8,0,0,0.4));
            padding:10px;
            border-radius:12px;
            border:1px solid var(--glass-2);
            max-width:100%;
        }

        .controls .left, .controls .center, .controls .right{ display:flex; gap:8px; align-items:center }

        button{
            background:transparent;
            border:1px solid rgba(255,45,45,0.08);
            color:inherit;
            padding:8px 12px;
            border-radius:10px;
            font-size:13px;
            cursor:pointer;
        }

        button.primary{ background: linear-gradient(180deg, rgba(255,45,45,0.14), rgba(255,45,45,0.06)); border-color: rgba(255,45,45,0.35); color:#fff }
        button.muted{ opacity:0.85 }

        input[type="text"], select{
            background:transparent;
            border:1px solid rgba(255,255,255,0.03);
            color:inherit;
            padding:8px 10px;
            border-radius:10px;
            font-size:13px;
            min-width:120px;
        }

        input::placeholder{ color: rgba(255,255,255,0.35) }

        label{ color:var(--muted); font-size:13px }

        #msg{ margin-top:12px; color: #ffbfbf; font-size:13px }

        @media (max-width:720px){
            #videos{ flex-direction:column; }
            video{ max-width:100%; }
            .controls{ padding:12px }
        }
    </style>
</head>
<body>
    <header class="topbar">
        <div>
            <div class="brand">Video Chat</div>
            <div class="subtitle">Minimal peer-to-peer calls</div>
        </div>
        <div class="subtitle">secure • low-latency • no server media</div>
    </header>

    <div id="videos">
        <video id="preview" playsinline autoplay muted></video>
        <div id="remoteVideos"></div>
    </div>

    <div class="controls">
        <div class="left">
            <button id="startBtn" class="primary">Start</button>
            <button id="stopBtn" disabled class="muted">Stop</button>
            <label><input type="checkbox" id="muteAudio"> mute</label>
        </div>

        <div class="center">
            <select id="videoSelect"></select>
            <select id="audioSelect"></select>
        </div>

        <div class="right">
            <input type="text" id="peerId" placeholder="Your ID">
            <button id="connectBtn" disabled>Connect</button>
            <input type="text" id="remotePeerId" placeholder="Peer ID">
            <button id="callBtn" disabled>Call</button>
        </div>
    </div>

    <div id="msg"></div>

    <script>
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const preview = document.getElementById('preview');
        const msg = document.getElementById('msg');
        const muteAudio = document.getElementById('muteAudio');
        const videoSelect = document.getElementById('videoSelect');
        const audioSelect = document.getElementById('audioSelect');

        let currentStream = null;

        async function listDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const vids = devices.filter(d => d.kind === 'videoinput');
                const auds = devices.filter(d => d.kind === 'audioinput');

                videoSelect.innerHTML = vids.map(v => `<option value="${v.deviceId}">${v.label || 'Camera ' + (vids.indexOf(v)+1)}</option>`).join('');
                audioSelect.innerHTML = auds.map(a => `<option value="${a.deviceId}">${a.label || 'Microphone ' + (auds.indexOf(a)+1)}</option>`).join('');
            } catch (e) {
                // enumerateDevices may fail if no prior permission; ignore silently
            }
        }

        async function start() {
            stop(); // stop any existing stream
            msg.textContent = '';
            const constraints = {
                video: videoSelect.value ? { deviceId: { exact: videoSelect.value } } : true,
                audio: audioSelect.value ? { deviceId: { exact: audioSelect.value } } : true
            };
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream;
                preview.srcObject = stream;
                preview.muted = muteAudio.checked;
                startBtn.disabled = true;
                stopBtn.disabled = false;
                await listDevices(); // update labels now that permission is granted
            } catch (err) {
                msg.textContent = 'Could not get camera/microphone: ' + (err && err.message ? err.message : err);
            }
        }

        function stop() {
            if (!currentStream) return;
            currentStream.getTracks().forEach(t => t.stop());
            preview.srcObject = null;
            currentStream = null;
            startBtn.disabled = false;
            stopBtn.disabled = true;
        }

        // Keep preview audio muted based on checkbox
        muteAudio.addEventListener('change', () => {
            preview.muted = muteAudio.checked;
        });

        startBtn.addEventListener('click', start);
        stopBtn.addEventListener('click', stop);

        // Peer connection setup
        const peerId = document.getElementById('peerId');
        const connectBtn = document.getElementById('connectBtn');
        const remotePeerId = document.getElementById('remotePeerId');
        const callBtn = document.getElementById('callBtn');
        const endBtn = document.createElement('button');
        endBtn.id = 'endCallBtn';
        endBtn.textContent = 'End';
        endBtn.disabled = true;
        endBtn.className = '';
        // append end button next to callBtn
        callBtn.parentNode.insertBefore(endBtn, callBtn.nextSibling);
    let peer = null;
    let currentCall = null;
    let currentDataConn = null; // DataConnection used to notify hangup

        function updateButtons() {
            connectBtn.disabled = !currentStream || !!peer;
            callBtn.disabled = !remotePeerId.value || !peer || !currentStream;
            endBtn.disabled = !currentCall;
        }

        function setupPeer() {
            if (!currentStream) {
                msg.textContent = 'Start camera/mic before connecting.';
                return;
            }

            if (peer) {
                console.debug('Peer already exists:', peer.id);
                // Update UI with existing peer ID if available
                if (peer.id) {
                    peerId.value = peer.id;
                    msg.textContent = 'Connected to server. Share your ID with friends!';
                }
                return;
            }

            // Initialize PeerJS with random ID generation
            peer = new Peer(undefined, {
                debug: 2 // Enable debug logging
            });

            peer.on('open', (id) => {
                console.debug('Connected with peer ID:', id);
                peerId.value = id;
                msg.textContent = 'Connected to server. Share your ID with friends!';
                updateButtons();
            });

            // Handle disconnection from the signaling server
            peer.on('disconnected', () => {
                console.warn('Disconnected from signaling server, attempting to reconnect...');
                msg.textContent = 'Connection lost. Reconnecting...';
                peer.reconnect();
            });

            // Handle permanent disconnection
            peer.on('close', () => {
                console.warn('Connection closed');
                msg.textContent = 'Connection closed. Please refresh to reconnect.';
                peer = null;
                updateButtons();
            });

            peer.on('call', (call) => {
                // auto-answer after confirmation
                if (confirm(`Accept call from ${call.peer}?`)) {
                    call.answer(currentStream);
                    handleCall(call);
                    // ensure a data connection exists for hangup signalling
                    setupDataConnection(call.peer);
                } else {
                    // optionally notify caller
                    call.close();
                }
            });

            peer.on('error', (err) => {
                msg.textContent = 'Connection error: ' + (err && err.message ? err.message : err);
            });
        }

        // NOTE: removed strict stream-equality checks because track IDs may occasionally
        // collide or be reported similarly across environments; instead we rely on
        // the MediaStream contents and connection peer IDs to manage duplicates.

        function handleCall(call) {
            // Close any existing call first
            if (currentCall && currentCall !== call) {
                try { currentCall.close(); } catch(e){}
            }
            currentCall = call;
            updateButtons();

            const remoteElId = 'remote-' + call.peer;

            call.on('stream', (remoteStream) => {
                console.debug('Received remote stream from', call.peer, remoteStream);

                const videoTracks = remoteStream.getVideoTracks();
                if (videoTracks.length === 0) {
                    console.warn('No video tracks in remote stream');
                    msg.textContent = 'Peer camera not available';
                    return;
                }

                // Monitor track states (Keep existing monitoring logic)
                videoTracks.forEach(track => {
                    track.onended = () => {
                        console.warn('Video track ended');
                        msg.textContent = 'Peer video disconnected';
                    };
                    track.onmute = () => {
                        console.warn('Video track muted');
                        msg.textContent = 'Peer video muted';
                    };
                    track.onunmute = () => {
                        console.debug('Video track unmuted');
                        msg.textContent = '';
                    };
                });

                let remoteVideo = document.getElementById(remoteElId);
                if (!remoteVideo) {
                    remoteVideo = document.createElement('video');
                    remoteVideo.id = remoteElId;
                    remoteVideo.playsinline = true;
                    remoteVideo.autoplay = true;
                    // Always start muted to increase chance of initial successful autoplay
                    remoteVideo.muted = true; 
                    remoteVideo.style.borderRadius = '10px';
                    remoteVideo.style.background = '#000';
                    document.getElementById('remoteVideos').appendChild(remoteVideo);
                }

                // --- Core Fix for Black Screen (Autoplay Issues) ---

                const playRemoteVideo = async () => {
                    // Check if stream is active before attempting to set
                    if (!remoteStream.active) {
                        console.warn('Remote stream not active, cannot play.');
                        msg.textContent = 'Remote stream is not active.';
                        return;
                    }

                    remoteVideo.srcObject = remoteStream;
                    msg.textContent = 'Connecting remote stream...';

                    try {
                        // Attempt to play the video. Browsers allow muted autoplay.
                        await remoteVideo.play();
                        
                        // If successful, attempt to UNMUTE it. This may fail and is fine.
                        remoteVideo.muted = false;
                        msg.textContent = '';
                        console.debug('Remote video playing successfully');
                    } catch (err) {
                        // Play failed (likely due to browser blocking unmuted autoplay)
                        console.warn('Autoplay failed, user interaction required:', err.name);
                        
                        // Fallback: Notify user to interact and add an event listener
                        msg.textContent = 'Click to enable video/audio from ' + call.peer;

                        const enablePlaybackOnClick = async () => {
                            // Check if playback is still paused
                            if (remoteVideo.paused) {
                                try {
                                    // Try playing again after user click/touch
                                    await remoteVideo.play();
                                    // Now it's playing, unmuting it should work.
                                    remoteVideo.muted = false;
                                    msg.textContent = '';
                                    console.debug('Playback enabled by user interaction.');
                                } catch (e) {
                                    console.error('Playback failed even after user interaction:', e);
                                    msg.textContent = 'Video playback failed. Try reconnecting.';
                                }
                            }
                            // Clean up the temporary listener
                            document.body.removeEventListener('click', enablePlaybackOnClick);
                        };
                        
                        // Attach the listener only if it hasn't been attached already
                        document.body.addEventListener('click', enablePlaybackOnClick, { once: true });
                    }
                };

                // Start the play sequence immediately
                playRemoteVideo();
            });

            call.on('close', () => {
                // stop remote tracks to avoid frozen video
                const rv = document.getElementById(remoteElId);
                if (rv && rv.srcObject) {
                    try { rv.srcObject.getTracks().forEach(t => t.stop()); } catch(e){}
                }
                document.getElementById(remoteElId)?.remove();
                if (currentCall === call) currentCall = null;
                // close associated data connection if any
                if (currentDataConn && currentDataConn.peer === call.peer) {
                    try { currentDataConn.close(); } catch(e){}
                    currentDataConn = null;
                }
                updateButtons();
            });

            call.on('error', () => {
                const rv = document.getElementById(remoteElId);
                if (rv && rv.srcObject) {
                    try { rv.srcObject.getTracks().forEach(t => t.stop()); } catch(e){}
                }
                document.getElementById(remoteElId)?.remove();
                if (currentCall === call) currentCall = null;
                if (currentDataConn && currentDataConn.peer === call.peer) {
                    try { currentDataConn.close(); } catch(e){}
                    currentDataConn = null;
                }
                updateButtons();
            });
        }


        function setupDataConnection(peerIdToConnect) {
            if (!peer) return;
            // If an existing data conn is open to same peer, reuse it
            if (currentDataConn && currentDataConn.open && currentDataConn.peer === peerIdToConnect) return;

            try {
                const dc = peer.connect(peerIdToConnect);
                currentDataConn = dc;

                dc.on('open', () => {
                    // ready to send/receive hangup messages
                });

                dc.on('data', (data) => {
                    // Expect { type: 'hangup' }
                    if (data && data.type === 'hangup') {
                        // remote asked to end the call
                        if (currentCall) {
                            try { currentCall.close(); } catch(e){}
                            currentCall = null;
                        }
                        // cleanup any remote videos
                        document.getElementById('remoteVideos')?.querySelectorAll('video').forEach(v => {
                            try { v.srcObject?.getTracks().forEach(t => t.stop()); } catch(e){}
                            v.remove();
                        });
                        msg.textContent = 'Peer ended the call';
                        // close this data connection
                        try { dc.close(); } catch(e){}
                        if (currentDataConn === dc) currentDataConn = null;
                        updateButtons();
                    }
                });

                dc.on('close', () => {
                    if (currentDataConn === dc) currentDataConn = null;
                    updateButtons();
                });

                dc.on('error', () => {
                    if (currentDataConn === dc) currentDataConn = null;
                    updateButtons();
                });
            } catch (e) {
                // ignore
            }
        }

        connectBtn.addEventListener('click', () => { setupPeer(); });

        callBtn.addEventListener('click', () => {
            if (!peer || !currentStream || !remotePeerId.value) return;
            try {
                // ensure a data connection exists so we can signal hangup
                setupDataConnection(remotePeerId.value);
                const call = peer.call(remotePeerId.value, currentStream);
                handleCall(call);
            } catch (err) {
                msg.textContent = 'Call failed: ' + (err && err.message ? err.message : err);
            }
        });

        endBtn.addEventListener('click', () => {
            // send hangup over data connection if available
            try {
                if (currentDataConn && currentDataConn.open) {
                    try { currentDataConn.send({ type: 'hangup' }); } catch (e) {}
                }
            } catch(e) {}

            // give the message a short moment to be delivered, then close
            setTimeout(() => {
                if (currentCall) {
                    try { currentCall.close(); } catch(e){}
                    currentCall = null;
                }

                // close data connection if open
                try { if (currentDataConn) { currentDataConn.close(); currentDataConn = null; } } catch(e){}

                // stop and remove any remote videos
                const container = document.getElementById('remoteVideos');
                container.querySelectorAll('video').forEach(v => {
                    try { v.srcObject?.getTracks().forEach(t => t.stop()); } catch(e){}
                    v.remove();
                });

                msg.textContent = 'You ended the call';
                updateButtons();
            }, 200);
        });

        // Enable call button when remote peer ID is entered
        remotePeerId.addEventListener('input', () => {
            updateButtons();
        });

        // Update device lists and enable connect button when stream starts
        async function start() {
            stop();
            msg.textContent = '';
            const constraints = {
                video: videoSelect.value ? { deviceId: { exact: videoSelect.value } } : true,
                audio: audioSelect.value ? { deviceId: { exact: audioSelect.value } } : true
            };
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream;
                preview.srcObject = stream;
                preview.muted = muteAudio.checked;
                startBtn.disabled = true;
                stopBtn.disabled = false;
                updateButtons();
                await listDevices();
            } catch (err) {
                msg.textContent = 'Could not get camera/microphone: ' + (err && err.message ? err.message : err);
            }
        }

        // Populate device lists on load (may be empty until permission granted)
        listDevices();

        // Helpful note for users when running from file:// or insecure origins
        if (location.protocol !== 'https:' && location.hostname !== 'localhost' && location.hostname !== '127.0.0.1') {
            const note = document.createElement('div');
            note.style.marginTop = '.6rem';
            note.style.color = '#666';
            note.textContent = 'Note: getUserMedia typically requires HTTPS or localhost. If permissions fail, serve this file over HTTPS or run a local server.';
            document.body.appendChild(note);
        }
    </script>
</body>
</html>